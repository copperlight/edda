# For more information on configuration options, see the Edda Docs site:
#
#   https://netflix.github.io/edda/configuration/
#

#######################################################################
# General Options
#######################################################################

#
# Set if this instance will be polling multiple accounts
# value can be comma separated, each value can be substituted
# for $account in later options
#
# edda.accounts=

#
# Set the region for the AWS endpoints
#
edda.region=${EC2_REGION}

#
# Set a region for a specific account
#
# edda.$account.region=us-east-1

# configure roles
#edda.aws.roleArn="arn:aws:iam::"${EC2_OWNER_ID}":role/Edda"
#edda.singleton.aws.roleArn="arn:aws:iam::"${TARGET_ACCOUNT_ID}":role/Edda"

#######################################################################
# Collection Options
#######################################################################

#
# how frequently should the Secondary Edda servers refresh the in-memory cache
# value is in milliseconds
#
edda.collection.cache.refresh=30000

#
# the cache refresh rates per account/collection
#
# edda.collection.$account.$collection.cache.refresh=30000

#
# How frequently should the Primary Edda server crawl the resources
# for updates.  The value is in milliseconds
#
# Rate can also be specified by collection, account, or both:
#
# edda.collection.$account.refresh=120000
# edda.collection.$collection.refresh=120000
# edda.collection.$account.$collection.refresh=120000
#
edda.collection.refresh=120000

#
# refresh cloudformation data every hour by default
#
edda.collection.aws.stacks.refresh=3600000

#
# Set crawl rate per collection
#
# edda.collection.$account.$collection.refresh=60000

#
# Stagger the collection load from the datastore so that
# we dont hammer the datastore on startup
#
edda.collection.jitter.enabled=false

#
# enable/disable a collection.  Value is boolean
#
# edda.collection.$account.$collection.enabled=false

edda.crawler.pageSize=100
edda.crawler.aws.functions.pageSize=50
edda.crawler.aws.iamRoles.pageSize=1000
edda.crawler.aws.instances.pageSize=1000
edda.crawler.aws.instanceStatuses.pageSize=1000
edda.crawler.aws.loadBalancers.pageSize=400
edda.crawler.aws.natGateways.pageSize=1000
edda.crawler.aws.networkInterfaces.pageSize=1000
edda.crawler.aws.securityGroups.pageSize=1000
edda.crawler.aws.snapshots.pageSize=1000
edda.crawler.aws.volumes.pageSize=500

edda.collection.enabled=false
edda.collection.aws.addresses.enabled=true
edda.collection.aws.alarms.enabled=true
edda.collection.aws.appLoadBalancers.enabled=true
edda.collection.aws.autoScalingGroups.enabled=true
edda.collection.aws.cacheClusters.enabled=true
edda.collection.aws.cacheSubnetGroups.enabled=true
edda.collection.aws.databases.enabled=true
edda.collection.aws.dbClusters.enabled=true
edda.collection.aws.dbSecurityGroups.enabled=true
edda.collection.aws.functions.enabled=true
edda.collection.aws.globalClusters.enabled=true
edda.collection.aws.hostedRecords.enabled=true
edda.collection.aws.hostedZones.enabled=true
edda.collection.aws.iamRoles.enabled=true
edda.collection.aws.images.enabled=true
edda.collection.aws.instances.enabled=true
edda.collection.aws.instanceStatuses.enabled=true
edda.collection.aws.launchConfigurations.enabled=true
edda.collection.aws.loadBalancers.enabled=true
edda.collection.aws.natGateways.enabled=true
edda.collection.aws.networkInterfaces.enabled=true
edda.collection.aws.routeTables.enabled=true
edda.collection.aws.scalingPolicies.enabled=true
edda.collection.aws.scheduledActions.enabled=true
edda.collection.aws.securityGroups.enabled=true
edda.collection.aws.snapshots.enabled=true
edda.collection.aws.subnets.enabled=true
edda.collection.aws.targetGroups.enabled=true
edda.collection.aws.transitGatewayAttachments.enabled=true
edda.collection.aws.transitGatewayRouteTables.enabled=true
edda.collection.aws.transitGateways.enabled=true
edda.collection.aws.volumes.enabled=true
edda.collection.aws.vpcEndpoints.enabled=true
edda.collection.aws.vpcEndpointServiceConfigurations.enabled=true
edda.collection.aws.vpcPeeringConnections.enabled=true
edda.collection.aws.vpcs.enabled=true
edda.collection.group.autoScalingGroups.enabled=true
edda.collection.group.clusters.enabled=true
edda.collection.view.appLoadBalancerAttributes.enabled=true
edda.collection.view.appLoadBalancerListeners.enabled=true
edda.collection.view.appLoadBalancerRules.enabled=true
edda.collection.view.images.enabled=true
edda.collection.view.instances.enabled=true
edda.collection.view.loadBalancerAttributes.enabled=true
edda.collection.view.loadBalancerInstances.enabled=true
edda.collection.view.targetGroupAttributes.enabled=true
edda.collection.view.targetGroupHealth.enabled=true

#
# Edda can automatically truncate old records from your backend data store
#
# Like other collections this setting can be specific to a collection,
# account, or both.
#
# There are three supported purge policies for record retention:
#
#   NONE           => Keep Forever (Default)
#   LIVE           => Only keep current records (mimics the AWS API)
#   AGE;expiry=N   => Remove records after expiry in milliseconds (N)
#
# edda.collection.purgeFrequency=86400000            # 24 hours in ms
# edda.collection.purgePolicy=AGE;expiry=2678400000  # 31 days in ms

#######################################################################
# Crawler Options
#######################################################################

#
# Field patterns to serialize to JSON when converting a Java Bean to a JSON document
#
edda.bean.argPattern="[^a-zA-Z0-9_]"

#
# List of tags (comma seperated) to suppress the values
# of when crawling AWS resources.  This is for tags where
# the value is constantly changing (ie timestamps)
#
# edda.crawler.aws.suppressTags=myTag

#
# sometimes AWS does not return tags.  If tags are actively used on your
# collections this will cause false document revisions as the tags come and go
# from the crawled AWS result.  Enable this boolean option to
# cause Edda to ignore crawl results that do not contain tags
#
# edda.crawler.$account.$collection.abortWithoutTags=true

#
# edda can automatically throttle AWS API access if it hits the account limit.
# when AWS returns a throttling/limit error an internal counter is activated
# and begans delaying requests by the throttle delay (in milliseconds).
#
# edda.crawler.throttle.enabled=false
# edda.crawler.throttle.delay=200

#
# if AWS continues to throw limit errors after the throttling is activated
# the delay will be increased until a maximum number of attempts is reached,
# after which the run will be aborted and an exception will appear in the logs
#
# if the multiplier is 225 and the delay is 200 each request will wait
#  200*225 milliseconds, or 45 seconds before hitting the API
#
# edda.crawler.throttle.maxDelayMultiplier=225

#
# if you have other applications using the AWS API and want to avoid
# hitting the API request limit edda can pace its requests by delaying
# each call and/or randomizing a delay in ms (jitter) on every call. these
# options can be combined and should be tuned carefully.
#
# the default behavior is to hit the API as quickly as possible on each crawl.
# values are in milliseconds.
#
# throttling will increase this number, so setting a request delay of 5000
# and using the default throttle settings would result in a maximum wait time
# of (5000+(200*225)) milliseconds or 50 seconds per request when the API
# limit is reached
#
# edda.crawler.requestDelay=0
#
# edda.crawler.jitter.enabled=false
# edda.crawler.jitter.max=2000

#
# enable/disable a crawler for a collection.  Rarely used, you should
# probably disable the collection instead of the crawler.
#
# edda.crawler.$account.$collection.enabled=false

#######################################################################
# Elector Options
#######################################################################

#
# leadership election frequency, in milliseconds
#
edda.elector.refresh=10000

#
# use DynamoDB write consistency to determine leadership
#
edda.elector.class="com.netflix.edda.aws.DynamoDBElector"

# the account details to use for aws authenticaion
# edda.elector.dynamodb.account=

#
# how long to give unresponsive leader before assuming it is no longer active
#
edda.elector.dynamodb.leaderTimeout=60000
edda.elector.dynamodb.tableName="edda-"${EDDA_STACK}"_leader"
edda.elector.dynamodb.readCapacity=5
edda.elector.dynamodb.writeCapacity=1

#######################################################################
# S3Current Datastore Options
#######################################################################
#
# S3Current Datastore writes active records to S3 and uses DynamoDB
# for transactional consistency.

# edda.datastore.current.class=com.netflix.edda.datastores.S3CurrentDatastore

# the account details to use for aws authenticaion
#edda.s3current.account=

edda.s3current.table="edda-"${EDDA_STACK}"_collections-index"
edda.s3current.readCapacity=10
edda.s3current.writeCapacity=1

# S3 bucket to write collection data
edda.s3current.bucket="edda."${EC2_REGION}".collections"

# Path in S3 bucket to write collection data
edda.s3current.locationPrefix="edda-"${EDDA_STACK}
